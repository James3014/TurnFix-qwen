# 專案實作規劃 - TurnFix

## 1. 專案現狀
經過兩輪的規格釐清，所有 High、Medium、Low 優先級的釐清項目均已解決。
目前已具備一份相對完整且明確的規格文件，包含：
-   **資料模型**：`spec/erm.dbml` (已更新)
-   **功能模型**：`spec/features/*.feature` (已更新)
-   **術語詞彙表**：`prompt/Glossary.md` (已建立)

## 2. 實作階段目標
根據已釐清的規格，本階段目標是完成 TurnFix 系統的 MVP (Minimum Viable Product) 實作，涵蓋核心資料庫、後端 API、前端介面及基礎測試。

## 2.1 里程碑規劃

-   **第一週：基礎架構與核心資料模型**
    *   完成資料庫 schema 設計與建置 (DB-101 ~ DB-105)。
    *   搭建後端 API 基礎框架。
    *   完成 RAG 知識來源預處理流程 (RAG-251)。
    *   建立專案根目錄結構與基本配置文件 (INF-1501)。

-   **第二週：症狀辨識與 RAG 整合**
    *   開發「症狀辨識」API (API-201)。
    *   設計並實作向量資料庫或可檢索索引 (RAG-252)。
    *   實作 RAG 檢索機制 (RAG-253)。
    *   整合大型語言模型 (LLM) (RAG-255)。
    *   設計並實作使用者輸入介面 (UI-301)。

-   **第三週：建議生成與追問**
    *   開發「建議生成」API (API-202)，包括數量限制驗證 (API-202.4)。
    *   開發「自適應追問」API (API-203)。
    *   實作 RAG 生成機制 (RAG-254)。
    *   設計並實作練習卡展示介面 (UI-302)。

-   **第四週：回饋、後台與測試**
    *   開發「使用者回饋」API (API-204)。
    *   開發「管理者後台」API (API-205)。
    *   設計並實作使用者回饋介面 (UI-303)。
    *   設計並實作管理者後台介面 (UI-304)。
    *   編寫所有功能的自動化測試 (TEST-401 ~ TEST-405)。
    *   完成 MVP 整合測試與部署。

## 3. 技術選型
選用輕量化方案以快速實現 MVP，但架構設計考慮未來擴展：

-   **後端框架**：Python (3.9+) + FastAPI (0.100+)
    - 理由：高效能、自動 API 文件、型別檢查支援
-   **前端框架**：React (18+) + TypeScript (5.0+)
    - 理由：豐富生態系、元件化架構、TypeScript 支援
-   **資料庫**：SQLite (開發階段) / PostgreSQL (部署階段，例如 Supabase)
    - 理由：輕量、無需額外伺服器、易於部署 (開發階段)；完整功能支援 (部署階段)
-   **ORM**：SQLAlchemy (2.0+)
    - 理由：支援多種資料庫，易於未來遷移
-   **向量資料庫**：ChromaDB (0.4+)
    - 理由：輕量化、易於整合、支援 Python
-   **AI/LLM**：Sentence Transformers (2.2+) + Hugging Face Models
    - 理由：開源、支援本地化部署
-   **部署方案**：Vercel (前端) + Vercel Functions (後端) + Supabase (資料庫)
    - 理由：無伺服器架構、自動擴展、易於維護

## 3.1 擴展準備
為確保未來可擴展性，採用六邊形架構（端口與適配器模式）：
- 業務邏輯與技術實現分離
- 預留技術組件替換接口
- 使用抽象層設計，便於未來遷移

## 3.2 實現層簡化原則
遵循 Linus Torvalds 的"好品味"原則進行實現：
- 消除不必要的複雜度，避免過度工程
- 保持實現簡單直接，專注於解決核心問題
- 使用簡單函數而非複雜物件導向設計
- 確保向後兼容性，不破壞現有接口

## 4. 實作範圍

### 4.1 資料庫層 (Database Layer)
-   **設計與建置**：根據 `spec/erm.dbml` 建立實際的資料庫 schema。
-   **實體**：Symptom, PracticeCard, Session, SymptomPracticeMapping。
-   **欄位約束**：確保所有 `id` 欄位為正數 (>0)。
-   **關聯**：實現 Symptom 與 PracticeCard 之間的多對多關聯。
-   **ORM 實作**：使用 SQLAlchemy 建立 ORM 模型，確保與資料庫抽象層分離，便於未來遷移。
-   **資料庫遷移**：使用 Alembic 管理資料庫 schema 變更，預留未來擴展接口。
-   **數量限制邏輯**：在後端服務層實現，確保每個症狀對應 3-5 張練習卡。

### 4.2 後端 API 層 (Backend API Layer)
-   **架構模式**：採用六邊形架構（端口與適配器模式）
    - 核心業務邏輯與技術實現分離
    - 介面抽象層設計，便於替換技術組件
-   **症狀辨識功能**：
    -   實現口語問題到標準症狀的「多對一」映射邏輯。
    -   實現同義詞庫的動態擴充機制。
    -   使用 NLP 技術或 ML 模型進行語義理解
-   **建議生成功能**：
    -   根據關聯性分數和使用者條件（等級、地形、風格）選擇和排序練習卡。
    -   處理練習卡數量邊界條件（不足 3 張時回傳所有符合的，超過 5 張時選取前 5 張）。
    -   **數量限制驗證**：在後端服務層實現，確保每個症狀對應 3-5 張練習卡。
-   **自適應追問功能**：
    -   實現多種置信度不足的判斷標準（模型機率、多個相近症狀、口語簡短模糊、缺少 Slot 資訊）。
    -   結合通用問題庫和缺失資訊動態生成追問問題。
-   **使用者回饋功能**：
    -   提供 API 記錄使用者對建議的評分 (`feedback_rating`) 和自由文字評論 (`feedback_text`)。
-   **管理者後台 API**：
    -   提供 API 接口用於管理症狀種子、練習卡和同義詞庫。

### 4.3 前端介面層 (Frontend UI Layer)
-   **架構**：採用 React + TypeScript，使用組件化設計
-   **狀態管理**：使用 Context API 或 Redux 進行狀態管理
-   **路由管理**：使用 React Router 進行頁面導航
-   **樣式處理**：使用 CSS-in-JS 或 Tailwind CSS
-   **使用者輸入介面**：
    -   提供輸入口語問題的文字框。
    -   提供選填資訊（等級、地形、風格）的選擇介面。
-   **練習卡展示介面**：
    -   根據練習卡類型展示不同格式的練習卡內容。
-   **使用者回饋介面**：
    -   提供評分（👍/👎）和自由文字回饋的輸入介面。
-   **管理者後台介面**：
    -   提供基礎的 CRUD (Create, Read, Update, Delete) 介面，用於管理症狀種子、練習卡和同義詞庫。

### 4.4 RAG 架構與 AI 實作

#### 4.4.1 RAG 架構 (MVP 階段)

-   **知識來源**：教練文字答覆、影片逐字稿（僅初～中級相關）。
-   **知識庫建立**：
    -   對知識來源進行預處理（清洗、分段）。
    -   使用 Sentence Transformers 進行向量化
    -   將處理後的知識儲存於向量資料庫 (ChromaDB) 或可檢索的索引中。
-   **檢索機制 (Retrieval)**：
    -   當使用者輸入問題時，系統會從知識庫中檢索出與問題最相關的知識片段。
-   **生成機制 (Generation)**：
    -   將檢索出的知識片段與使用者問題結合，形成優化後的提示詞 (Prompt)。
    -   將優化後的提示詞發送給 Hugging Face 模型。
    -   模型根據提示詞生成練習卡的 `goal`, `tips`, `pitfalls`, `dosage`, `self_check` 等內容。

#### 4.4.2 AI 擴展規劃 (未來方向)

-   **目標**：讓 AI 模型更直接地參與到「決定給什麼練習卡」的環節，以提高精準度。
-   **擴展方向**：
    1.  **AI 輔助症狀辨識**：
        *   讓模型根據使用者問題和 RAG 檢索出的知識，對「症狀種子」進行更深層次的語義理解和判斷。
        *   模型可以輔助計算「症狀/條件置信度」，更精準地觸發「自適應追問」。
    2.  **AI 參與練習卡選擇與排序**：
        *   讓模型根據使用者問題、RAG 檢索出的知識，以及使用者條件，直接推薦最適合的練習卡 ID 列表。
        *   模型可以動態調整練習卡與症狀之間的「關聯性分數」，或生成更個性化的排序邏輯。

### 4.5 測試 (Testing)
-   **測試策略**：
    -   單元測試：測試獨立功能和服務
    -   整合測試：測試組件間的協作
    -   端到端測試：測試完整使用者流程
-   **測試框架**：使用 Pytest 進行後端測試，React Testing Library 進行前端測試
-   **自動化測試**：根據 `spec/features/*.feature` 中的 Gherkin 場景，編寫對應的自動化測試。

### 4.6 安全性與效能
-   **安全性**：
    -   輸入驗證與清理
    -   防止注入攻擊
    -   API 速率限制
-   **效能**：
    -   API 回應時間目標：P95 < 2.5s
    -   使用快取機制提升效能
    -   非同步處理長時間任務

### 5. 潛在優化與擴展 (未來版本考慮)
-   **使用者帳號系統**：為記錄使用狀況和問答狀況提供基礎。
-   **語音輸入支援**：在 MVP 完成後評估。
-   **更精細的排序權重**：在 `SymptomPracticeMapping` 中引入更複雜的排序權重機制。
-   **練習卡類型擴展**：考慮如何靈活支持更多練習卡類型。
-   **擴展準備**：當需要遷移到更複雜的系統時：
    -   資料庫：從 SQLite 遷移至 PostgreSQL
    -   向量資料庫：從 ChromaDB 遷移至 Weaviate 或 Pinecone
    -   後端：拆分為微服務架構
    -   前端：採用服務端渲染或靜態產生

## 6. 部署與運維策略

### 6.1 Serverless 部署方案
- **前端部署**：Vercel
    - 自動從 Git 倉庫部署
    - CDN 分發，全球加速
    - 內建預覽環境
- **後端部署**：Vercel Functions (Serverless Functions)
    - 無伺服器，自動擴展
    - 按使用量計費
    - 最大執行時間限制需考慮 AI 計算時間
- **資料庫**：Supabase (PostgreSQL-based)
    - 伺服器端即服務
    - 直接整合到前端框架
    - 支援即時功能

### 6.2 監控與日誌策略
- **日誌收集**：Vercel Analytics + Supabase 日誌
- **效能監控**：Vercel Speed Insights
- **錯誤追蹤**：Sentry (若需要更詳細追蹤)
- **健康檢查**：自定義 API 健康檢查端點

### 6.3 資料備份與災難恢復
- **自動備份**：Supabase 內建資料庫備份功能
- **災難恢復**：制定資料庫還原程序
- **版本控制**：程式碼與配置使用 Git 管理

### 6.4 擴展準備
- 當 Serverless 限制成為瓶頸時，可遷移至傳統主機或混合雲方案
- 預留 API 接口供未來整合專用 AI 計算服務

## 7. 參考文件
-   `spec/erm.dbml`：資料模型規格
-   `spec/features/*.feature`：功能模型規格
-   `prompt/Glossary.md`：標準術語詞彙表
